// This file is autogenerated
using System.Collections;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;


namespace XenoAtom.Collections;

partial struct UnsafeList<T>
{
    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 2.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N2.DebugListViewN2)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N2 : IEnumerable<T>
    {
        private FixedArray2 _items;
        private int _count;

        public readonly int Capacity => 2;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray2, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N2 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN2 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN2 : IEnumerator<T>
        {
            private readonly N2 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN2(N2 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN2(N2 collection)
        {
            private readonly N2 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(2)]
        private struct FixedArray2
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 4.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N4.DebugListViewN4)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N4 : IEnumerable<T>
    {
        private FixedArray4 _items;
        private int _count;

        public readonly int Capacity => 4;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray4, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N4 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN4 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN4 : IEnumerator<T>
        {
            private readonly N4 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN4(N4 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN4(N4 collection)
        {
            private readonly N4 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(4)]
        private struct FixedArray4
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 8.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N8.DebugListViewN8)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N8 : IEnumerable<T>
    {
        private FixedArray8 _items;
        private int _count;

        public readonly int Capacity => 8;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray8, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N8 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN8 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN8 : IEnumerator<T>
        {
            private readonly N8 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN8(N8 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN8(N8 collection)
        {
            private readonly N8 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(8)]
        private struct FixedArray8
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 16.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N16.DebugListViewN16)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N16 : IEnumerable<T>
    {
        private FixedArray16 _items;
        private int _count;

        public readonly int Capacity => 16;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray16, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N16 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN16 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN16 : IEnumerator<T>
        {
            private readonly N16 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN16(N16 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN16(N16 collection)
        {
            private readonly N16 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(16)]
        private struct FixedArray16
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 32.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N32.DebugListViewN32)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N32 : IEnumerable<T>
    {
        private FixedArray32 _items;
        private int _count;

        public readonly int Capacity => 32;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray32, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N32 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN32 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN32 : IEnumerator<T>
        {
            private readonly N32 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN32(N32 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN32(N32 collection)
        {
            private readonly N32 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(32)]
        private struct FixedArray32
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 64.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N64.DebugListViewN64)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N64 : IEnumerable<T>
    {
        private FixedArray64 _items;
        private int _count;

        public readonly int Capacity => 64;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray64, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N64 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN64 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN64 : IEnumerator<T>
        {
            private readonly N64 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN64(N64 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN64(N64 collection)
        {
            private readonly N64 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(64)]
        private struct FixedArray64
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 128.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N128.DebugListViewN128)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N128 : IEnumerable<T>
    {
        private FixedArray128 _items;
        private int _count;

        public readonly int Capacity => 128;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray128, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N128 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN128 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN128 : IEnumerator<T>
        {
            private readonly N128 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN128(N128 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN128(N128 collection)
        {
            private readonly N128 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(128)]
        private struct FixedArray128
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 256.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N256.DebugListViewN256)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N256 : IEnumerable<T>
    {
        private FixedArray256 _items;
        private int _count;

        public readonly int Capacity => 256;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray256, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N256 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN256 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN256 : IEnumerator<T>
        {
            private readonly N256 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN256(N256 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN256(N256 collection)
        {
            private readonly N256 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(256)]
        private struct FixedArray256
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 512.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N512.DebugListViewN512)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N512 : IEnumerable<T>
    {
        private FixedArray512 _items;
        private int _count;

        public readonly int Capacity => 512;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray512, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N512 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN512 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN512 : IEnumerator<T>
        {
            private readonly N512 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN512(N512 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN512(N512 collection)
        {
            private readonly N512 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(512)]
        private struct FixedArray512
        {
            private T _0;
        }
    }

    /// <summary>
    /// Represents a list of <typeparamref name="T"/> with a fixed capacity of 1024.
    /// </summary>
    [DebuggerTypeProxy(typeof(UnsafeList<>.N1024.DebugListViewN1024)), DebuggerDisplay("Count = {_count}")]
    [ExcludeFromCodeCoverage]
    public struct N1024 : IEnumerable<T>
    {
        private FixedArray1024 _items;
        private int _count;

        public readonly int Capacity => 1024;

        public readonly int Count => _count;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int count)
        {
            _count = count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnsafeSetCount(int capacity, int count)
        {
            _count = count;
        }

        public readonly ref T UnsafeFirstRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get => ref Unsafe.As<FixedArray1024, T>(ref Unsafe.AsRef(in _items));
        }

        [UnscopedRef]
        public readonly Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref UnsafeFirstRef, _count);

        public readonly bool IsReadOnly => false;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear()
        {
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                AsSpan().Clear();
            }
            _count = 0;
        }

        public readonly N1024 Clone() => this;

        public readonly bool Contains(T item) => IndexOf(item) >= 0;

        public readonly void CopyTo(Span<T> array)
        {
            AsSpan().CopyTo(array);
        }

        public readonly T[] ToArray()
        {
            var array = new T[_count];
            CopyTo(array);
            return array;
        }

        public void Reset()
        {
            Clear();
            _count = 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Add(T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [UnscopedRef]
        public ref T UnsafeGetOrCreate(nint index)
        {
            if ((uint)index >= (uint)_count)
            {
                var newCount = index + 1;
                if ((uint)newCount <= (uint)Capacity)
                {
                    _count = (int)newCount;
                }
                else
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
                }
            }

            return ref UnsafeGetRefAt(index);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddByRef(in T item)
        {
            var count = _count;
            if ((uint)count <= (uint)Capacity)
            {
                _count = count + 1;
                UnsafeGetRefAt(count) = item;
            }
            else
            {
                ThrowHelper.ThrowListFullInvalidOperationException();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Insert(nint index, T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertByRef(nint index, in T item)
        {
            var count = _count;
            if ((uint)index > (uint)count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            if ((uint)count == Capacity) ThrowHelper.ThrowListFullInvalidOperationException();

            if (index < count)
            {
                var span = AsSpan();
                span.Slice((int)index, (int)(count - index)).CopyTo(((Span<T>)_items).Slice((int)(index + 1)));
            }
            UnsafeGetRefAt(index) = item;
            _count = count + 1;
        }

        public bool Remove(T element)
        {
            var index = IndexOf(element);
            if (index >= 0)
            {
                RemoveAt(index);
                return true;
            }
            return false;
        }

        public void Sort(Comparison<T> comparison) => AsSpan().Sort(comparison);

        public void Sort<TComparer>() where TComparer : IComparer<T>, new() => Sort(new TComparer());
    
        public void Sort<TComparer>(TComparer comparer) where TComparer : IComparer<T>
        {
            AsSpan().Sort(comparer);
        }

        public void SortByRef<TComparer>(in TComparer comparer) where TComparer : struct, IComparerByRef<T>
        {
            AsSpan().SortByRef(comparer);
        }

        public readonly nint IndexOf(T element)
        {
            var comparer = EqualityComparer<T>.Default;
            var count = _count;
            for (nint i = 0; i < count; i++)
            {
                if (comparer.Equals(UnsafeGetRefAt(i), element))
                {
                    return i;
                }
            }

            return -1;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RemoveAt(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;
            if (index < _count)
            {
                var span =((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }

            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
        }
    
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T RemoveAtAndGet(nint index)
        {
            if ((uint)index >= (uint)_count) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index);
            _count--;

            // previous children
            var item = UnsafeGetRefAt(index);
            if (index < _count)
            {
                var span = ((Span<T>)_items);
                span.Slice((int)(index + 1), (int)(_count - index)).CopyTo(span.Slice((int)index));
            }
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                UnsafeGetRefAt(_count) = default!;
            }
            return item;
        }

        public T RemoveLast()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationRemoveOnEmptyList();

            _count--;
            ref var removed = ref UnsafeGetRefAt(_count);
            if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
            {
                removed = default!;
            }
            return removed;
        }

        public ref T this[nint index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            [UnscopedRef]
            get
            {
                if ((uint)index >= (uint)_count) ThrowHelper.ThrowIndexOutOfRangeException(index);
                return ref UnsafeGetRefAt(index);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [UnscopedRef]
        public readonly ref T UnsafeGetRefAt(nint index) => ref Unsafe.Add(ref UnsafeFirstRef, index);

        public void Push(T element)
        {
            Add(element);
        }

        [UnscopedRef]
        public readonly ref T Peek()
        {
            if (_count == 0) ThrowHelper.ThrowInvalidOperationPeekOnEmptyList();
            return ref UnsafeGetRefAt(_count - 1);
        }

        public T Pop() => RemoveAtAndGet(_count - 1);

        public EnumeratorN1024 GetEnumerator() => new(this);

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public struct EnumeratorN1024 : IEnumerator<T>
        {
            private readonly N1024 _list;
            private nint _index;
            private T _current;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal EnumeratorN1024(N1024 list)
            {
                this._list = list;
                _index = 0;
                _current = default!;
            }

            public T Current => _current;

            object IEnumerator.Current => Current!;


            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                if (_index < _list._count)
                {
                    _current = _list[_index];
                    _index++;
                    return true;
                }
                return MoveNextRare();
            }

            private bool MoveNextRare()
            {
                _index = _list._count + 1;
                _current = default!;
                return false;
            }

            void IEnumerator.Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [ExcludeFromCodeCoverage]
        private sealed class DebugListViewN1024(N1024 collection)
        {
            private readonly N1024 _collection = collection;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public T[] Items
            {
                get
                {
                    var array = new T[this._collection._count];
                    _collection.CopyTo(array);
                    return array;
                }
            }
        }

        [InlineArray(1024)]
        private struct FixedArray1024
        {
            private T _0;
        }
    }

}
